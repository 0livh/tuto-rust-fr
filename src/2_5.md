# Spécificités de Rust

## Durée de vie (ou lifetime)

Il existe deux types de durée de vie :

 - Les durées de vie statiques.
 - Les autres.

Les durées de vie statiques permettent d'avoir des références sur des variables statiques ou du contenu "constant" :

```Rust
// Avec une variable statique :
static VAR: i32 = 0;
let variable_statique: &'static i32 = &VAR;

// Avec une constante :
const CONST_VAR: i32 = 0;
let variable_constante: &'static i32 = &CONST_VAR;

// Avec du contenu constant (car une string écrite "en dur" dans le code est
// stockée telle quelle dans le code compilé) :
let variable_const: &'static str = "Ceci est une str constante !";
```

Une durée de vie statique veut donc dire que le contenu qu'elle référence vivra du début à la fin du programme.

Les autres durées de vie sont un peu plus complexes mais aussi moins visibles la plupart du temps. Imaginons que l'on écrive une structure dont l'un des champs devait être modifié à l'extérieur de la structure. On se contenterait de renvoyer `&mut self.ma_variable`. Bien que ce code fonctionne, il est important de comprendre ce qu'il se passe :

```Rust
struct MaStruct {
    variable: String,
}

impl MaStruct {
    fn get_variable(&mut self) -> &mut String {
        &mut self.variable
    }
}

fn main() {
    let mut v = MaStruct { variable: String::new() };

    v.get_variable().push_str("hoho !");
    println!("{}", v.get_variable());
}
```

La méthode ``get_variable`` va en fait renvoyer une référence __temporaire__ sur __self.variable__. Si on voulait écrire ce code de manière "complète", on l'écrirait comme ceci :

```Rust
impl MaStruct {
    fn get_variable<'a>(&'a mut self) -> &'a mut String {
        &mut self.variable
    }
}
```

__'a__ représente la durée de vie (cela aurait tout aussi bien pu être __'x__ ou __'z__, peu importe). Ici, on retourne donc une référence avec une durée de vie __'a__ sur une variable.

Ici le compilateur fait ce que l'on appelle de __l'élision__. Comme il n'y a qu'une seule durée de vie possible pour cette variable, il la déduit automatiquement donc pas besoin de l'ajouter nous-même. Cependant il y a beaucoup de cas où il ne peut pas, comme par-exemple :

```Rust
fn foo(a: &str, b: &str) -> &str {
    a
}

fn main() {
    let c = foo("a", "b");
}
```

Ce code renvoie cette erreur :

```Shell
1 | fn foo(a: &str, b: &str) -> &str {
  |           ----     ----     ^ expected named lifetime parameter
```

Dans le cas présent, il y a plusieurs durées de vie possibles et il ne sait pas laquelle choisir, il faut donc ajouter les durées de vie nous-même :

```Rust
fn foo<'a, 'b>(a: &'a str, b: &'b str) -> &'a str {
    a
}

fn main() {
    let c = foo("a", "b");
}
```

### Contraintes sur les durées de vie

Tout comme on peut ajouter des contraintes sur les traits avec les __supertraits__, on peut aussi ajouter des contraintes sur les durées de vie :

```Rust
fn foo<'a, 'b: 'a>(a: &'a str, b: &'b str) -> &'a str {
    a
}
```

Ici, on dit que la durée de vie `'b` doit vivre __au moins aussi longtemps__ que `'a`. Cela reste cependant une utilisation avancée des durées de vie et il y a peu de chances que vous en croisiez, mais il semblait important que vous soyiez au courant au cas où vous veniez à en croiser.
