#Spécificités de Rust
##Généricité

Reprenons donc notre précédent exemple :

```Rust
fn affiche_chat(chat: &Chat) -> String {
    println!("{} est un {}", chat.get_nom(), chat.get_espece());
}

fn affiche_chien(chien: &Chien) -> String {
    println!("{} est un {}", chien.get_nom(), chien.get_espece());
}
```

Comme je vous le disais, avec deux espèces d'animaux, ça ne représente que 2 fonctions mais ça deviendra très vite long à écrire si on veut en rajouter 40. C'est donc ici qu'intervient la généricité.

###La généricité

Commençons par la base en donnant une description de ce que c'est : "c'est une fonctionnalité qui autorise le polymorphisme paramétrique (ou juste polymorphisme pour aller plus vite)". Pour faire simple, ça permet de manipuler des objets différents du moment qu'ils implémentent le trait demandé.

Par-exemple, on pourrait manipuler un chien robot, il implémenterait le trait Machine et le trait Animal :

```Rust
trait Machine {
    fn get_nombre_de_vis(&self) -> usize;
    fn numero_de_serie(&self) -> String;
}

trait Animal {
    fn get_nom(&self) -> String;
    fn get_nombre_de_pattes(&self) -> usize;
}

struct ChienRobot {
    nom: String,
    nombre_de_pattes: usize,
    numero_de_serie: String
}

impl Animal for ChienRobot {
    fn get_nom(&self) -> String {
        self.nom
    }

    fn get_nombre_de_pattes(&self) -> usize {
        self.nombre_de_pattes
    }
}

impl Machine for ChienRobot {
    fn get_nombre_de_vis(&self) -> usize {
        40123
    }

    fn get_numero_de_serie(&self) -> String {
        self.numero_de_serie
    }
}
```

Ainsi, il nous est désormais possible de faire :

```Rust
fn presentation_animal<T: Animal>(animal: T) {
    println!("Il s'appelle {} et il a {} patte()s !", animal.get_nom(),
        animal.get_nombre_de_pattes());
}

let super_chien = ChienRobot {
                    nom: "Super chien",
                    nombre_de_pattes: 4,
                    numero_de_serie: "super chien DZ442"
                };

presentation_animal(super_chien);
```

Mais comme c'est aussi un robot, on peut aussi faire :

```Rust
fn description_machine<T: Robot>(machine: T) {
    println!("Le modèle {} a {} vis", machine.get_numero_serie(),
        machine.get_nombre_de_vis());
}
```

C'est pas trop génial ? :waw:

Cependant, je vais vous exposer un cas auquel il faudra faire très attention dans vos développements logiciels, utilisant l'héritage.

Un code comme celui suivant ne compilera pas:

```Rust
trait Animal {
    fn get_nom(&self) -> String {
        self.nom
    }

    fn get_nombre_de_pattes(&self) -> usize {
        self.nombre_de_pattes
    }
}

struct Chien {
    nom: String,
    nombre_de_pattes: usize
}

struct Chat {
    nom: String,
    nombre_de_pattes: usize
}

struct Oiseau {
    nom: String,
    nombre_de_pattes: usize
}

struct Araignee {
    nom: String,
    nombre_de_pattes: usize
}

impl Animal for Chien {}
impl Animal for Chat {}
impl Animal for Oiseau {}
impl Animal for Araignee {}

fn affiche_animal<T: Animal>(animal: T) {
    println!("Cet animal s'appelle {} et il a {} patte(s)", animal.get_nom(),
        animal.get_nombre_de_pattes());
}

let chat = Chat { nom : "Félix", nombre_de_pattes: 4};
let spider = Araignee { nom : "Yuuuurk", nombre_de_pattes: 8};

affiche_animal(chat);
affiche_animal(spider);
```

Pourquoi?

Tout simplement parce que les traits ne peuvent prendre en compte dans les méthodes par défaut le travail sur des valeurs prises en compte dans l'objet en paramètre (ici: "self")!  
En effet, ils ne peuvent prendre en compte des attributs qui, peut-être, ne seront pas contenus dans des structures en héritant!

Voici un code fonctionnant pour ce cas :

```Rust
struct Chien {
    nom: String,
    nombre_pattes: usize
}

struct Chat {
    nom: String,
    nombre_pattes: usize
}

trait Animal {
    fn getNom(&self) -> ();
    fn getNbPattes(&self) -> ();
    fn affiche(&self) -> () {
        println!("Je suis un animal");
    }
}

//On implémente les méthodes prévues dans le trait Animal, sauf celui par défaut (si non surcharge)
impl Animal for Chien {
    fn getNom(&self) -> () {
        println!("{}", self.nom);
    }
    fn getNbPattes(&self) -> () {
        println!("{}", self.nombre_pattes);
    }
}

//On fait de même, mais l'on a quand même envie de surcharger la méthode par défaut...
impl Animal for Chat {
    fn getNom(&self) -> () {
        println!("{}", self.nom);
    }
    fn getNbPattes(&self) -> () {
        println!("{}", self.nombre_pattes);
    }
    //On peut même 'surcharger' une méthode par défaut dans le trait - il suffit de la réimplémenter
    fn affiche(&self) -> () {
        println!("Je suis un animal - un chat même!");
    }
}

fn main() {
    let chien = Chien {nom : "Rufus".to_string(), nombre_pattes : 4};
    let chat = Chat {nom : "Félix".to_string(), nombre_pattes : 4};

    chien.getNom(); //doit afficher "Rufus"
    chat.getNbPattes(); //doit afficher "4"
    chien.affiche(); //doit afficher "Je suis un animal"
    chat.affiche(); //doit afficher "Je suis un animal - un chat même!"
}
```

La seule contrainte étant que, même si l'implémentation des méthodes est la même, il faudra, à chaque structure héritant d'un trait, la réimplémenter...
