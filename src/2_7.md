#Spécificités de Rust
##Déréférencement

Après les gros chapitres précédents, celui-là ne devrait pas vous prendre beaucoup de temps. Il vous arrivera de croiser ce genre de code :

```Rust
fn une_fonction(x: &mut i32) {
    *x = 2; // on déréférence
}

fn main() {
    let x = 0;

    println!("avant : {}", x);
    une_fonction(&mut x);
    println!("après : {}", x);
}
```

La valeur a donc été modifiée dans la fonction `une_fonction`. Pour ceux ayant fait du C/C++, il pourrait se dire que c'est exactement la même chose qu'avec un pointeur. Hé bien ils se trompent ! Le déréférencement fait appel au trait [Deref](https://doc.rust-lang.org/stable/std/ops/trait.Deref.html). Dans le cas présent, c'est le type `&mut u32` qui l'implémente.

###Implémentation

On va prendre un exemple pour que vous compreniez le tout plus facilement :

```Rust
use std::ops::Deref; // on importe le trait

struct UneStruct {
    value: u32
}

impl Deref for UneStruct {
    type Target = u32; // pour préciser quel type on retourne !

    fn deref(&self) -> &u32 {
        &self.value
    }
}

fn main() {
    let x = UneStruct { value: 0 };
    assert_eq!(0u32, *x); // on peut maintenant déréférencer x
}
```

###Auto-déréférencement

Vous utilisez aussi ce trait quand vous faites :

```Rust
fn affiche_la_str(s: &str) {
    println!("affichage : {}", s);
}

let x = "toto".to_owned(); // on a donc une String("toto")
affiche_la_str(&x); // on passe une &String
```

Normalement, vous devriez vous demander : "Pourquoi si on passe `&String` on obtient `&str` ?!". Hé bien sachez que Rust implémente un système __d'auto-déréférencement__. Ça permet d'écrire des codes de ce genre :

```Rust
struct UneStruct;

impl UneStruct {
    fn foo(&self) { println!("UneStruct"); }
}

let f = UneStruct;

f.foo();
(&f).foo();
(&&f).foo();
(&&&&&&&&f).foo();
```

Le compilateur va déréférencer jusqu'à obtenir le type voulu (en l'occurrence, celui qui implémente la méthode `foo` dans le cas présent, donc `UneStruct`). Je pense que certains d'entre vous ont compris où je voulais en venir concernant `String`.

Le compilateur voit qu'on envoie `&String` dans une méthode qui reçoit `&str` comme paramètre. Il va donc déréférencer `String` pour obtenir `str`. Nous obtenons donc `&str`. On peut imager ce que fait le compilateur de cette façon : `&(*String)`.
