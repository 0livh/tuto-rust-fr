# Aller plus loin
## Ajouter des tests

Ce chapitre parlera des tests et de la métadonnée `#[test]`.
En Rust, il est possible d'écrire des tests unitaires directement dans un fichier qui peuvent être lancés par __Cargo__ ou le compilateur de __Rust__.

Avec __Cargo__ :

```Shell
> cargo test
```

Avec __rustc__ :

```Shell
> rustc --test votre_fichier_principal.rs
> ./votre_fichier_principal
```

Regardons maintenant comment créer ces tests unitaires :

### La métadonnée #[test]

Pour indiquer au compilateur que cette fonction est un test unique, il faut ajouter `#[test]`. Exemple :

```Rust
fn some_func(valeur1: i32, valeur2: i32) -> i32 {
    valeur1 + valeur2
}

#[test]
fn test_some_func() {
    assert_eq!(3, some_func(1, 2));
}
```

Plutôt facile, non ? Vous pouvez aussi mettre cette balise sur un module :

```Rust
fn some_func(valeur1: i32, valeur2: i32) -> i32 {
    valeur1 + valeur2
}

#[cfg(test)] // on ne compile que si on est en mode "test"
mod tests {
    use super::some_func;

    #[test] // on doit le remettre pour bien spécifier au compilateur que c'est un test
    fn test_some_func() {
        assert_eq!(3, some_func(1, 2));
    }
}
```

Ça permet de découper un peu le code.

### La métadonnée #[should_panic]

Maintenant, si vous voulez vérifier qu'un test __échoue__, il vous faudra utiliser cette balise :

```Rust
fn some_func(valeur1: i32, valeur2: i32) -> i32 {
    valeur1 + valeur2
}

#[test] // c'est un test
#[should_panic] // il est censé paniquer
fn test_some_func() {
    assert_eq!(4, some_func(1, 2)); // 1 + 2 != 4, donc ça doit paniquer
}
```

Quand vous lancerez l'exécutable, il vous confirmera que le test s'est bien déroulé (parce qu'il a paniqué). Petit bonus : vous pouvez ajouter du texte qui sera affiché lors de l'exécution du test :

```Rust
#[test]
#[should_panic(expected = "1 + 2 != 4")]
fn test_some_func() {
    assert_eq!(4, some_func(1, 2));
}
```

### Mettre les tests dans un dossier à part

Si vous utilisez __Cargo__, il est aussi possible d'écrire des tests dans un dossiers à part. Commencez par créer un dossier __tests__ puis créez un fichier .rs.

Dans ce fichier, il vous faudra importer votre bibliothèque pour pouvoir tester ses fonctions :

```Rust
extern crate ma_lib;

#[test]
fn test_some_func() {
    assert_eq!(3, ma_lib::some_func(1, 2));
}
```

#### Écrire des suites de tests

Si vous shouhaitez regrouper plusieurs tests dans un même dossier (mais toujours dans le dossier __tests__), rien de bien difficile une fois encore. Ça devra ressembler à ça :

```
 - tests
    |
    |- la_suite_de_tests.rs
    |- sous_dossier
        |
        |- fichier1.rs
        |- fichier2.rs
        |- mod.rs
```

Je pense que vous voyez déjà où je veux en venir : il va juste falloir importer le module **sous_dossier** pour que les tests contenus dans __fichier1.rs__ et __fichier2.rs__ soient exécutés.

##### la_suite_de_tests.rs

```Rust
mod sous_dossier; // Et c'est tout !
```

##### sous_dossier/mod.rs

```Rust
mod fichier1;
mod fichier2;
```

Et voilà ! Vous pouvez maintenant écrire tous les tests que vous voulez dans __fichier1.rs__ et __fichier2.rs__ (en n'oubliant pas d'ajouter `#[test]` !).
