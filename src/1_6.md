# Les bases de la programmation en Rust

## Les boucles

Nous les avons vu très rapidement à la fin du chapitre précédent, donc approfondissons le sujet :

Les boucles sont l'une des bases de la programmation, il est donc impératif de regarder comment elles fonctionnent en Rust.

### while

Comme dans les autres langages, elle continue tant que sa condition est respectée. Exemple :

```Rust
let mut i: i32 = 0;

while i < 10 {
    println!("bonjour !");
    i += 1;
}
```

Ici, le programme affichera bonjour tant que i sera inférieur à 10.

Il faut cependant faire attention à plusieurs choses :

-   Vous noterez encore une fois qu'il n'y a pas de parenthèse autour de la condition !
-   Tout comme pour les conditions, les accolades sont encore une fois __obligatoires__ !

Il existe aussi la possibilité d'écrire des boucles infinies avec le mot clé __loop__ (plutôt qu'un `while true`) :

### loop

Je pense que vous vous demandez tous : "mais à quoi ça peut bien nous servir ?". Prenons un exemple : un jeu vidéo. L'affichage doit continuer en permanence jusqu'à ce que l'on quitte. Plutôt que d'écrire :

```Rust
while true {
    //...
}

// ou

let mut end = false;

while end == false {
    //...
}
```

On écrira tout simplement :

```Rust
loop {
    //...
}
```

Maintenant vous vous dites sans doute : "Ok, mais comment on l'arrête cette boucle ?". Tout simplement avec le mot-clé __break__ . Reprenons notre exemple du début :

```Rust
let mut i: i32 = 0;

loop {
    println!("bonjour !");
    i += 1;
    if i > 10 {
        break;
    }
}
```

Petit rappel concernant les mots-clés __break__ et __return__ : le mot-clé __break__ permet seulement de quitter la __boucle__ courante :

```Rust
loop {
    println!("Toujours là !");
    let mut i = 0i32;
    
    loop {
        println!("sous-boucle !");
        i += 1;
        if i > 2 {
            // et on revient dans la boucle précédente
            break;
        }
    }
}
```

Tandis que le mot-clé __return__ fait quitter la __fonction__ courante :

```Rust
fn main() {
    loop {
        println!("Toujours là !");
        let mut i = 0i32;
        
        loop {
            println!("sous-boucle !");
            i += 1;
            if i > 2 {
                // on quitte la fonction main et donc le programme se termine
                return;
            }
        }
    }
}
```

### for

La boucle for est un peu plus complexe que les deux précédentes. Elle ne fonctionne qu'avec des objets implémentant le trait [__IntoIterator__](https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html). Vous ne savez pas ce qu'est un __trait__ ? ,Pour le moment ce n'est pas important, nous y reviendrons plus tard. Prenons maintenant des exemples de comment fonctionne la boucle __for__ :

```Rust
for i in 0..10 {
    println!("i vaut : {}", i);
}
```

Ce qui va afficher :

```Shell
i vaut : 0
i vaut : 1
i vaut : 2
i vaut : 3
i vaut : 4
i vaut : 5
i vaut : 6
i vaut : 7
i vaut : 8
i vaut : 9
```

La variable __i__, créée pour la boucle __for__, prendra successivement toutes les valeurs allant de 0 à 9, puis la boucle prendra fin.

Certains d'entre vous doivent se demander si je n'ai pas menti en disant que la boucle __for__ ne s'utilisait que sur des objets en voyant ce "0..10". Hé bien sachez que non, ce "0..10" est considéré comme un objet de type [__Range__](https://doc.rust-lang.org/stable/std/ops/struct.Range.html) qui implémente le trait [__IntoIterator__](https://doc.rust-lang.org/stable/std/iter/trait.IntoIterator.html). J'insiste sur le fait que c'est tout à fait normal si vous ne comprenez pas toutes mes explications pour l'instant !

Prenons un deuxième exemple :

```Rust
let v = vec!(1, 4, 5, 10, 6);

for value in v {
    println!("{}", value);
}
```

Ce qui va afficher :

```Shell
1
4
5
10
6
```

### Énumération

Si vous souhaitez savoir combien de fois vous avez itéré, vous pouvez utiliser la fonction [enumerate](https://doc.rust-lang.org/nightly/std/iter/trait.Iterator.html#method.enumerate) :

```Rust
for (i, j) in (5..10).enumerate() {
    println!("i = {} et j = {}", i, j);
}
```

Ce qui affichera :

```Shell
i = 0 et j = 5
i = 1 et j = 6
i = 2 et j = 7
i = 3 et j = 8
i = 4 et j = 9
```

__i__ vaut donc le nombre d'itérations effectuées à l'intérieur de la boucle tandis que __j__ prend successivement les valeurs range. Autre exemple :

```Rust
let v = vec!("a", "b", "c", "d");

for (i, value) in v.iter().enumerate() {
    println!("i = {} et value = \"{}\"", i, value);
}
```

### Les boucles nommées

Encore une autre chose intéressante à connaître : __les boucles nommées__ ! Mieux vaut commencer par un exemple :

```Rust
// 'outer désigne le nom ou label de la boucle ci-dessous :
'outer: for x in 0..10 {
    'inner: for y in 0..10 {
        // on continue la boucle sur x
        if x % 2 == 0 { continue 'outer; }

        // on continue la boucle sur y
        if y % 2 == 0 { continue 'inner; }

        println!("x: {}, y: {}", x, y);
    }
}
```

Je pense que vous l'aurez compris, on peut directement reprendre ou arrêter une boucle en utilisant __son nom__ (pour peu que vous lui en ayez donné un bien évidemment). Autre exemple :

```Rust
'global: for _ in 0..10 {
    'outer: for x in 0..10 {
        'inner: for y in 0..10 {
            // on arrête la boucle qui s'appelle global
            if x > 3 { break 'global; }

            // on continue la boucle sur x
            if x % 2 == 0 { continue 'outer; }

            // on continue la boucle sur y
            if y % 2 == 0 { continue 'inner; }

            println!("x: {}, y: {}", x, y);
        }
    }
}
```

Encore une fois, je vous invite à tester pour bien comprendre comment tout ça fonctionne. Quand ce sera bon, il sera temps de passer aux __fonctions__ !
